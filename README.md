# SI-330-HW4-Filtering-Web-Logs-with-Regular-Expressions

Homework instructions

SI 330 Winter 2017 Homework 4: Regular Expressions
Due Date:  Saturday, Feb 4, 2017 @ 11:59pm
Objectives:
Parsing and filtering with regular expressions
Continued practice manipulating delimited text files
Submission Instructions:
After completing this homework, you will turn in one file via Canvas ->  Assignments: a zip file named si330-hw4-YOUR_UNIQUE_NAME.zip that contains the following files: 
Your python script: si330-hw4-YOUR_UNIQUE_NAME.py
This file should be based on the provided homework-4-template.py
Your output files based on the full access log (access_log.txt):
valid_access_log_YOUR_UNIQUE_NAME.txt
invalid_access_log_YOUR_UNIQUE_NAME.txt
verbs_tlds_YOUR_UNIQUE_NAME.txt
A text file containing your answers to questions:
si330-hw4-YOUR_UNIQUE_NAME.txt
	This file should be based on the provided homework-4-template.txt

This homework involves multiple steps: you will get credit for each step you complete successfully. You should complete the steps one by one and verify that you’ve completed each correctly before moving on to the next one.

Part 0. Getting started: Download files
This homework will apply your knowledge of Python regular expressions to an important real-world problem: filtering Web access logs.  A Web access log records every HTTP request made to a Web server, along with features such as the date, time, IP address of the computer making the HTTP request, and the request’s resulting status code (e.g. 200 == success).  Log analysis and filtering is an important method for identifying valid vs. suspicious requests, as you will see from this assignment. 

First, download and unzip the file si330w17-homework-4.zip from Canvas > Files > Week 4 > Homework 4

You should see these files:

access_log.txt
access_log_first_1000_lines.txt
valid_access_log_desired_output_first_1000_lines.txt
invalid_access_log_desired_output_first_1000_lines.txt
homework-4-template.py
homework-4-template.txt

The file access_log.txt is an actual HTTP server log from a security researcher who set up a ‘honeypot’ server to attract hackers, in order to record the HTTP requests used in hacking attempts, to learn about their methods and origins. 

This access log was generated by a popular Web server program, Apache. It is in tab-delimited format: each line represents a row in a table, with columns separated by tabs ('\t' in python). 

Unlike many of the files we have seen so far, the access log file does not have a header row (i.e., it is missing the first row that would define the names of the columns in the file). Therefore, to process the file we need to know what the columns mean ahead of time. The columns of access_log.txt have the following meanings:

IP:            The IP address of the machine making the HTTP request
Ident:         [YOU CAN IGNORE THIS]
Userid:        [YOU CAN IGNORE THIS]
Timestamp:     The date and time the HTTP request was made
Timezone:      The time zone
HTTP_Request:  The HTTP request with three parts: An HTTP verb (typically GET or POST, 
               which are used to request data or send data, respectively) followed by 
               the URL being requested, followed by the HTTP Protocol version (typically
               “HTTP/1.0” or “HTTP/1.1”).
HTTP_Status:   The status code that indicates the result of the result
               (200: success, 404: page not found, etc.)
HTTP_Duration: length of HTTP session in milliseconds
HTTP_Referer:  [YOU CAN IGNORE THIS]
Browser_Type:  Browser type making the request

If you are curious, the format is described in more detail here, under the Access Log section, or in this Stack Overflow post. However, you are not likely to need to read either page to complete this assignment. 

When data for a field is not available, it will appear as '-' in the file.

Note: the access_log.txt file is about 42Mb uncompressed.   When you first test your program, we recommend using a smaller sample of the first 1000 lines of access_log.txt, namely, access_log_sample.txt that we've included in the zip file. You should browse through this sample to familiarize yourself with the format and think about how you might extract the data out of it. Then, for this homework, you will process the full version of the file access_log.txt.

Part 1.  Filter valid and invalid rows
We've provided a template python script for you to fill in called homework-4-template.py.  Rename this to your own version of the script: si330-hw4-YOUR_UNIQUE_NAME.py. 

Find the comment in the script file labeled “PART 1 CODE”. You will add code here that detects valid and invalid requests. The script will output two tab-delimited files: 
(a) A "valid entries" file that has all rows that meet a set of criteria (described below).
(b) An "invalid entries" file that has suspicious, invalid log file rows that did not pass the criteria below.

As you write your filtering code, you can validate your output against these provided files:

valid_access_log_first1000.txt
invalid_access_log_first1000.txt

If you find that your code validates against these two files, but you still don’t have the correct number of rows in your final output (at the end of this section), there are some extra validation files on Canvas containing the first 3000 rows of the “valid” and “invalid” files, and the last 10,000 rows of the “valid” file.

Criteria for “valid” requests

There is one log request per line. For the purposes of this assignment, we have defined “valid” and “invalid” requests as described below.

All valid entries MUST have:
 
The HTTP_status must be equal to 200
The HTTP_Request field consists of a Verb, followed by a URL, followed (optionally) by a Version. The Verb, URL, and Version are separated from each other by any number of whitespace characters. The HTTP_Request field may also have any amount of leading and trailing whitespace (e.g. “     Verb    URL     Version  “ is valid, as is 
“Verb URL Version”). Verb, URL, and Version are formatted as follows:
The Verb must be “GET” or “POST”
The URL must start with “http://” or “https://”
In the URL, “http://” or “https://” must be followed by one or more alphabetic characters (i.e. not a digit or a symbol).  For example, the URL should NOT start with “http:///”, which is an error (because of the third slash).
Domains in the URL must consist of only alphabetic letters. E.g. “http://www.abc.com” is valid, but “http://www.abc123.com” is not.
The top-level domain in the URL must consist of only letters. This is to say, if the host name is actually a numerical IP address like “202.96.254.200”, we don’t count it. If the whole domain name is just “.com” as in “http://.com/blah” or does not even contain a dot as in “http://c/blah”, we do not count it.

We covered top-level domains in Lab 4: The “hu” part in the hostname www.goldengate.hu is the top-level domain (representing the country of Hungary). 
The top-level domain can be followed by any of these three items:
A colon and a port number, e.g. “http://abcde.com:8080”. The 8080 part is called the port number. The port number is not part of the top-level domain. For the purposes of determining the host name, it should be ignored: The top-level domain of “http://abcde.com:8080” should be counted as “com”.
A slash, followed (optionally) by the remainder of the URL (up until the next whitespace). E.g., “http://abcde.com/” or “http://abcde.com/something+else” are both valid. If a port number is included, it can also be followed by a slash and the remainder of a URL; e.g. “http://abcde.com:8080/something+else” is valid.
Nothing (i.e. the top-level domain is the end of the URL); e.g. “http://abcde.com” is valid.
The Version must be “HTTP/1.0”, “HTTP/1.1”, or can be omitted (in other words, it can be “”)

Examples

This line in the log counts as a valid visit to the ‘hu’ top-level domain:

195.82.31.125 - - [09/Mar/2004:22:03:09 -0500] "GET http://www.goldengate.hu/cgi-bin/top/topsites.cgi?an12 HTTP/1.0" 200 558 "http://Afrique" "Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)"

This line parses as follows:
The HTTP_Request is GET http://www.goldengate.hu/cgi-bin/top/topsites.cgi?an12 HTTP/1.0, with:
Verb = GET
URL = http://www.goldengate.hu/cgi-bin/top/topsites.cgi?an12
	(having top-level domain hu)
Version = HTTP/1.0
The HTTP_status is 200

An example of an invalid line would be the following:
 
68.48.142.117 - - [09/Mar/2004:22:41:42 -0500] "GET /scripts/..%c1%9c../winnt/system32/cmd.exe?/c+dir HTTP/1.0" 200 566 "-" "-"
 
This is because /scripts/ obviously doesn't look like a web address since it doesn’t start with http:// or https:// ). This is a prime example of an attempt to get a file stored locally on that proxy server to exploit vulnerabilities. 
 
Hints

All of the criteria for HTTP_Request (i.e. everything except the check on HTTP_status) can be implemented using a single regular expression. It is also possible to solve this assignment using a regular expression combined with some other string operations.

Once you've made all appropriate changes to the script for part 1, you should see this output and final counts when running on the full access log:

Wrote 64879 rows to valid_access_log_YOURUNIQNAME.txt
Wrote 137266 rows to invalid_access_log_YOURUNIQNAME.txt

As you get close, make sure to use a file compare utility to help with line-by-line compare of your output file with the desired output (see Part 3). It should be clear which lines do not match, and you will likely see a pattern for what needs to be fixed in order to correct the matches.
 
Part 2. Pulling out useful information
Once you are satisfied that your code is correctly filtering valid and invalid requests, modify it so that it pulls out three pieces of information from the HTTP_Request column: the Verb, the Version, and the top-level domain. 

We want to add these pieces of information as additional columns in each row, named “Verb”, “Version”, and “Top_Level_Domain”, and then output a new file containing only this information, called verbs_tlds_YOURUNIQNAME.txt

To do this, add code at the line marked “PART 2 CODE” to add the extracted values to each row, and uncomment the indicated line in the main() function to output the file. You can validate your output against verbs_tlds_first1000.txt
Once you complete this section, your output should give:

Wrote 64879 rows to valid_access_log_YOURUNIQNAME.txt
Wrote 137266 rows to invalid_access_log_YOURUNIQNAME.txt
Wrote 64879 rows to verbs_tlds_YOURUNIQNAME.txt

Part 3.  How to check your output with these useful debugging tools
 
As you work on Parts 1 and 2, you may want to compare your output against the sample output to debug your code. To compare your output with the desired output files, you can use a handy “file compare” utility to see which lines are different.  On Windows, try http://winmerge.org/  For the Mac, some people recommend   http://www.sourcegear.com/diffmerge/  Both of these should be free.

You can also use PyCharm’s built-in diff utility, by selecting two files in your project, right-clicking, and selecting Compare Files:





These file compare utilities will show you:
Which lines you filtered out in your output, but still exist in the desired output
Which lines you did not filter in your output, but are not part of the desired output
Which lines are in both your output, and the desired output.

If all the lines in your output are of type #3, then you're done: you've matched the desired output exactly.  
If you have some lines of type #1 in the "valid" output, it means your filtering was too strict: you should carefully examine the criteria you're using, including the regular expressions.

If you have some lines of type #2 in the "valid" output, it means you didn't filter out all the invalid lines and may have missed some criteria in your filtering loop.


Part 4.  Remember to change to the full file before you submit
Remember to change the call to read_log_file('access_log_sample.txt') in main() to read from the full file before you submit: read_log_file('access_log.txt')


 



